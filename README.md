MiniShell (msh) üöÄUna implementaci√≥n personalizada de una shell de UNIX desarrollada en C. Este proyecto demuestra el uso avanzado de llamadas al sistema de bajo nivel para la creaci√≥n de procesos, comunicaci√≥n mediante pipes, redirecciones de entrada/salida y control de trabajos (jobs).‚ú® Caracter√≠sticasEl proyecto implementa las funcionalidades nucleares de una terminal moderna:Ejecuci√≥n de Mandatos: Ejecuci√≥n de programas externos usando fork, execvp y waitpid.Pipelines (Tuber√≠as): Soporte para encadenar m√∫ltiples comandos mediante pipes (|), permitiendo que la salida de uno sea la entrada del siguiente.Redirecciones:Entrada est√°ndar (<).Salida est√°ndar (>).Salida de errores (2>).Gesti√≥n de Trabajos (Job Control):Ejecuci√≥n en segundo plano (Background) usando el operador &.Comando interno jobs para listar procesos activos o detenidos.Comando interno bg para reanudar trabajos detenidos en segundo plano.Manejo de estados: RUNNING, STOPPED, FINISHED.Comandos Internos (Built-ins):cd: Cambio de directorio (soporta HOME por defecto).umask: Consulta y modificaci√≥n de la m√°scara de permisos de archivos.exit: Cierre controlado de la shell liberando recursos.Manejo de Se√±ales: Ignora SIGINT (Ctrl+C) y SIGTSTP (Ctrl+Z) en la shell principal para evitar cierres accidentales, permitiendo que solo los procesos en primer plano las reciban.üõ†Ô∏è Estructura del C√≥digoEl coraz√≥n de la minishell se divide en:Bucle principal: Lee la entrada del usuario y utiliza un parser para tokenizar los mandatos.Ejecutor simple: Gestiona mandatos √∫nicos y sus redirecciones.Ejecutor m√∫ltiple: Crea un array de pipes y gestiona la sincronizaci√≥n de m√∫ltiples procesos hijos concurrentes.Limpiador de procesos (process_cleanup): Utiliza waitpid con WNOHANG para recolectar procesos "zombie" en segundo plano sin bloquear la terminal.üöÄ Instalaci√≥n y UsoRequisitos previosCompilador gcc.Entorno basado en UNIX (Linux, macOS o WSL).Compilaci√≥nAseg√∫rate de tener los archivos parser.h y su implementaci√≥n en el mismo directorio:Bashgcc -Wall -Wextra main.c parser.c -o msh
Ejecuci√≥nBash./msh
üíª Ejemplos de usoEjecuci√≥n simple con redirecci√≥n:Bashmsh> ls -l > salida.txt
Uso de tuber√≠as complejas:Bashmsh> cat /etc/passwd | grep root | cut -d: -f1
Gesti√≥n de segundo plano:Bashmsh> sleep 100 &
[1] 12345
msh> jobs
[1]+  Running    sleep 100 &
üìÇ Requisitos T√©cnicos ImplementadosFuncionalidadLlamadas al Sistema UtilizadasCreaci√≥n de procesosfork()Ejecuci√≥nexecvp()Sincronizaci√≥nwaitpid(), WUNTRACED, WNOHANGComunicaci√≥npipe(), dup2(), close()Se√±alessignal(), kill(), SIGCONTArchivosopen(), umask(), chdir()üìÑ Notas del DesarrolladorEste proyecto utiliza un analizador l√©xico externo (parser.h) para transformar la l√≠nea de comandos en una estructura tline. Se ha puesto especial √©nfasis en la gesti√≥n din√°mica de memoria, asegurando que todos los pids y pipes reservados se liberen correctamente para evitar fugas de memoria.